<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/2024/assets/css/just-the-docs-default.css"> <script src="/2024/assets/js/vendor/lunr.min.js"></script> <script src="/2024/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/2024/favicon.ico" type="image/x-icon"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>online planning - Part II. | RL Theory</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="online planning - Part II." /> <meta property="og:locale" content="en_US" /> <meta name="description" content="PDF Version" /> <meta property="og:description" content="PDF Version" /> <link rel="canonical" href="http://localhost:4000/2024/lecture-notes/planning-in-mdps/lec6/" /> <meta property="og:url" content="http://localhost:4000/2024/lecture-notes/planning-in-mdps/lec6/" /> <meta property="og:site_name" content="RL Theory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2024-09-21T14:43:24-06:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="online planning - Part II." /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-21T14:43:24-06:00","datePublished":"2024-09-21T14:43:24-06:00","description":"PDF Version","headline":"online planning - Part II.","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/lecture-notes/planning-in-mdps/lec6/"},"url":"http://localhost:4000/2024/lecture-notes/planning-in-mdps/lec6/"}</script> <!-- End Jekyll SEO tag --> <!-- MathJax --> <!-- http://docs.mathjax.org/en/latest/web/start.html --> <!-- http://docs.mathjax.org/en/latest/web/configuration.html#web-configuration --> <!-- http://docs.mathjax.org/en/latest/options/input/tex.html --> <!-- http://docs.mathjax.org/en/latest/input/tex/eqnumbers.html --> <script> MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], processEscapes: true, tags: 'ams' } }; </script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <!-- Google fonts --> <!-- https://fonts.google.com/specimen/Merriweather?sidebar.open=true&selection.family=Merriweather:wght@400;900 --> <style> @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@400;900&display=swap'); </style> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000/2024/" class="site-title lh-tight"> RL Theory </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <div class="nav-category">Pages</div> <ul class="nav-list"><li class="nav-list-item"><a href="/2024/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/2024/pages/about/" class="nav-list-link">About CMPUT 605</a></li><li class="nav-list-item"><a href="/2024/pages/about_cmput653/" class="nav-list-link">About CMPUT 653 (OLD)</a></li><li class="nav-list-item"><a href="/2024/pages/lectures/" class="nav-list-link">Lectures</a></li><li class="nav-list-item"><a href="/2024/pages/assignments/" class="nav-list-link">The work you do</a></li></ul> <div class="nav-category">Lecture Notes</div> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Planning in MDPs category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/lecture-notes/planning-in-mdps" class="nav-list-link">Planning in MDPs</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec1/" class="nav-list-link">1. Introductions</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec2/" class="nav-list-link">2. The Fundamental Theorem</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec3/" class="nav-list-link">3. Value Iteration and Our First Lower Bound</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec4/" class="nav-list-link">4. Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec5/" class="nav-list-link">5. Online Planning - Part I.</a></li><li class="nav-list-item active"><a href="/2024/lecture-notes/planning-in-mdps/lec6/" class="nav-list-link active">6. online planning - Part II.</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec7/" class="nav-list-link">7. Function Approximation</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec8/" class="nav-list-link">8. Approximate Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec9/" class="nav-list-link">9. Limits of query-efficient planning</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec10/" class="nav-list-link">10. Planning under $q^*$ realizability</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec11/" class="nav-list-link">11. Planning under $v^*$ realizability (TensorPlan I.)</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec12/" class="nav-list-link">12. TensorPlan and eluder sequences</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec13/" class="nav-list-link">13. From API to Politex</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec14/" class="nav-list-link">14. Politex</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec15/" class="nav-list-link">15. From policy search to policy gradients</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec16/" class="nav-list-link">16. Policy gradients</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Online RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/lecture-notes/online-rl" class="nav-list-link">Online RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/lecture-notes/online-rl/lec22/" class="nav-list-link">22. Introduction</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/online-rl/lec23/" class="nav-list-link">23. Tabular MDPs</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/online-rl/lec24/" class="nav-list-link">24. Featurized MDPs</a></li></ul></li></ul> <div class="nav-category">Winter 2022 Lecture Notes</div> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Planning in MDPs category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2022-lecture-notes/planning-in-mdps" class="nav-list-link">Planning in MDPs</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec1/" class="nav-list-link">1. Introductions</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec2/" class="nav-list-link">2. The Fundamental Theorem</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec3/" class="nav-list-link">3. Value Iteration and Our First Lower Bound</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec4/" class="nav-list-link">4. Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec5/" class="nav-list-link">5. Online Planning - Part I.</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec6/" class="nav-list-link">6. online planning - Part II.</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec7/" class="nav-list-link">7. Function Approximation</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec8/" class="nav-list-link">8. Approximate Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec9/" class="nav-list-link">9. Limits of query-efficient planning</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec10/" class="nav-list-link">10. Planning under $q^*$ realizability</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec11/" class="nav-list-link">11. Planning under $v^*$ realizability (TensorPlan I.)</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec12/" class="nav-list-link">12. TensorPlan and eluder sequences</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec13/" class="nav-list-link">13. From API to Politex</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec14/" class="nav-list-link">14. Politex</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec15/" class="nav-list-link">15. From policy search to policy gradients</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec16/" class="nav-list-link">16. Policy gradients</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Batch RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2022-lecture-notes/batch-rl" class="nav-list-link">Batch RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/batch-rl/lec17/" class="nav-list-link">17. Introduction</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/batch-rl/lec18/" class="nav-list-link">18. Sample complexity in finite MDPs</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/batch-rl/lec19/" class="nav-list-link">19. Scaling with value function approximation</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Online RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2022-lecture-notes/online-rl" class="nav-list-link">Online RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/online-rl/lec22/" class="nav-list-link">22. Introduction</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/online-rl/lec23/" class="nav-list-link">23. Tabular MDPs</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/online-rl/lec24/" class="nav-list-link">24. Featurized MDPs</a></li></ul></li></ul> <div class="nav-category">Winter 2021 Lecture Notes</div> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Planning in MDPs category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2021-lecture-notes/planning-in-mdps" class="nav-list-link">Planning in MDPs</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec1/" class="nav-list-link">1. Introductions</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec2/" class="nav-list-link">2. The Fundamental Theorem</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec3/" class="nav-list-link">3. Value Iteration and Our First Lower Bound</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec4/" class="nav-list-link">4. Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec5/" class="nav-list-link">5. Local Planning - Part I.</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec6/" class="nav-list-link">6. Local Planning - Part II.</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec7/" class="nav-list-link">7. Function Approximation</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec8/" class="nav-list-link">8. Approximate Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec9/" class="nav-list-link">9. Limits of query-efficient planning</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec10/" class="nav-list-link">10. Planning under $q^*$ realizability</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec11/" class="nav-list-link">11. Planning under $v^*$ realizability (TensorPlan I.)</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec12/" class="nav-list-link">12. TensorPlan and eluder sequences</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec13/" class="nav-list-link">13. From API to Politex</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec14/" class="nav-list-link">14. Politex</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec15/" class="nav-list-link">15. From policy search to policy gradients</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec16/" class="nav-list-link">16. Policy gradients</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Batch RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2021-lecture-notes/batch-rl" class="nav-list-link">Batch RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/batch-rl/lec17/" class="nav-list-link">17. Introduction</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/batch-rl/lec18/" class="nav-list-link">18. Sample complexity in finite MDPs</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Online RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2021-lecture-notes/online-rl" class="nav-list-link">Online RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/online-rl/blank/" class="nav-list-link">Blank</a></li></ul></li></ul> </nav> <footer class="site-footer"> Website of the course CMPUT 653: Theoretical Foundations of Reinforcement Learning. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search RL Theory" aria-label="Search RL Theory" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="">Planning in MDPs</a></li> <li class="breadcrumb-nav-list-item"><span>6. online planning - Part II.</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <!-- Taken from https://github.com/jekyll/minima/blob/master/_layouts/post.html --> <header class="post-header"> <h1 class="post-title p-name" itemprop="name headline">6. online planning - Part II.</h1> <p class="text-small text-grey-dk-000 mb-0 mr-2"><time class="dt-published" datetime="2024-09-21T14:43:24-06:00" itemprop="datePublished"> Sep 21, 2024 </time></p> </header><p><a href="../../../documents/lectures/winter_2023/website_notes/planning_in_mdps/lec6.pdf">PDF Version</a></p> <p>In the previous lecture online planning was introduced. The main idea is to amortize the cost of planning by asking a planner to produce an action to be taken at a particular state so that the policy induced by repeatedly calling the planner at the states just visited and then using the action returned by the planner is near-optimal. We have seen that with this, the cost of planning can be made independent of the size of the state space – at least for deterministic MDPs. For this, one can use just a recursive implementation of value iteration, which, for convenience, we wrote using <strong>action-value functions</strong> and the corresponding Bellman optimality operator, $T$, defined by</p> \[\begin{align*} T q(s,a) = r_a(s) + \gamma \langle P_a(s), M q \rangle\,. \end{align*}\] <p>(in the previous lecture we used $\tilde T$ to denote this operator, but to reduce clutter from now on, we will drop the tilde).</p> <p>We have also seen that no procedure can do significantly better in terms of its runtime (or query cost) than this simple recursive procedure. In this lecture we show that these ideas also extend to the stochastic case.</p> <h2 id="sampling-may-save-the-day">Sampling May Save the Day?</h2> <p>Assume now that the MDP is stochastic. Recall the pseudocode of the recursive form of value iteration from the last lecture that computes $(T^k \boldsymbol{0})(s,\cdot)$:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. define q(k,s):
2.  if k = 0 return [0 for a in A] # base case
3.  return [ r(s,a) + gamma * sum( [P(s,a,s') * max(q(k-1,s')) for s' in S] ) for a in A ]
4. end
</code></pre></div></div> <p>Obviously, the size of the state space creeps in because in line 3 we need to calculate an expected value over the next state distribution at $(s,a)$. As noted beforehand, in deterministic systems when a simulator is available, the sum over the next-states can be replaced with a single simulator call. But the reader may remember from Probability 101 that sampling allows one to approximate expected values, where the <strong>error of approximation is independent of the cardinality of the set over which we average the values</strong>. Here, this set is $\mathcal{S}$, the state space. This is extremely lucky!</p> <p>To quantify the size of these errors, we recall Hoeffding’s inequality:</p> <hr /> <p><a name="lem:hoeff"></a> <strong>Lemma (Hoeffding’s Inequality):</strong> Given $m$ independent, identically distributed (i.i.d.) random variables that take values in the $[0,1]$ interval, for any \(0 \leq \zeta &lt; 1\), with probability at least \(1 - \zeta\) it holds that</p> \[\left| \frac{1}{m} \sum_{i=1}^m X_i - \mathbb{E}[X_1] \right| \leq \sqrt{\frac{\log \frac{2}{\zeta}}{2m} }\,.\] <hr /> <p>Letting $S_1’,\dots,S_m’ \stackrel{\textrm{i.i.d.}}{\sim} P_a(s)$ for some state-action pair $(s,a)$ and $v:S \to [0,v_{\max}]$, by this result, for any $0\le \zeta &lt;1$, with probability $1-\zeta$,</p> \[\begin{align} \left|\frac1m \sum_{i=1}^m v(S_i') - \langle P_a(s), v \rangle\right| \le v_{\max} \sqrt{\frac{\log \frac{2}{\zeta}}{2m} }. \label{eq:hoeffbop} \end{align}\] <p>This suggests the following approach: For <strong>each</strong> state action pair $(s,a)$ draw $S_1’,\dots,S_m’ \stackrel{\textrm{i.i.d.}}{\sim} P_a(s)$ and store it in a list $C(s,a)$. Then, whenever for some function $v$ we need the value of $\langle P_a(s), v \rangle$, just use the sample average</p> \[\frac1m \sum_{s'\in C(s,a)} v(s')\,.\] <p>Plugging this approximation into our previous pseudocode gives the following new code:</p> <div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>1. define q(k,s):
2.  if k = 0 return [0 for a in A] # base case
3.  return [ r(s,a) + gamma/m * sum( [max(q(k-1,s')) for s' in C(s,a)] ) for a in A ]
4. end
</code></pre></div></div> <p>The total runtime of this function is now $O( (m\mathrm{A})^{k+1} )$. What is important is that this will give us a compute time independent of the size of the state space as long as we can show that $m$ can be set independently of $\mathrm{S}$ while meeting our target for the suboptimality of the induced policy.</p> <p>This pseudocode sweeps under the rug on who creates the lists $C(s,a)$ and when? A simple and effective approach is to use “lazy evaluation” (or memoization): Create $C(s,a)$ at the first time it is needed (and do not create it otherwise). An alternative to the approach we follow here is to avoid storing these lists and just create them on demand. Both procedures are valid, but we will stick to the procedure that creates the lists only once and will comment on the other approach at the end in the notes.</p> <h2 id="good-action-value-approximations-suffice">Good Action-Value Approximations Suffice</h2> <p>As a first step towards understanding the strength and weaknesses of this approach, let us define $\hat T: \mathbb{R}^{\mathcal{S}\times\mathcal{A}} \to \mathbb{R}^{\mathcal{S}\times\mathcal{A}}$ by</p> \[(\hat T q)(s,a) = r_a(s) + \frac{\gamma}{m} \sum_{s'\in C(s,a)} \max_{a'\in \mathcal{A}} q(s',a')\,.\] <p>With the help of this definition, when called with state $s=s_0$, the planner computes</p> \[\begin{align*} A = \arg\max_{a\in \mathcal{A}} \underbrace{ (\hat T^H \boldsymbol{0})(s_0,a) }_{Q_H(s_0,a)}\,, \end{align*}\] <p>The conciseness of this formulae, if anything, must please everyone!</p> <p>Let us now turn to the question of whether the policy $\hat \pi$ induced by this planners is a good one. We start with a lemma that parallels our earlier result that bounded the suboptimality of a policy that is greedy w.r.t. a function over the states as a function of how well the function approximates the optimal value function. To state the lemma, we need the analog of optimal value functions but with action values.</p> <h3 id="suboptimality-of-epsilon-optimizing-policies">Suboptimality of $\epsilon$-optimizing policies</h3> <p>Define</p> \[q^*(s,a) = r_a(s) + \gamma \langle P_a(s), v^* \rangle\,.\] <p>We call this function $q^*$ the <strong>optimal action-value function</strong> (in our MDP). The function \(q^*\) is easily seen to satisfy \(M q^* = v^*\) and thus also \(q^* = T q^*\). The promised lemma is as follows:</p> <hr /> <p><a name="lem:averror"></a> <strong>Lemma (Policy error bound - I.):</strong> Let $\pi$ be a memoryless policy and choose a function $q:\mathcal{S}\times\mathcal{A} \to \mathbb{R}$ and $\epsilon\ge 0$. Then, the following hold:</p> <ol> <li> <p>If $\pi$ is <strong>$\epsilon$-optimizing</strong> in the sense that \(\sum_a \pi(a\vert s) q^*(s,a) \ge v^*(s)-\epsilon\) holds for every state $s\in \mathcal{S}$ then $\pi$ is $\epsilon/(1-\gamma)$ suboptimal: \(v^\pi \ge v^* - \frac{\epsilon}{1-\gamma} \boldsymbol{1}\,.\)</p> </li> <li> <p>If $\pi$ is greedy with respect to $q$ then $\pi$ is $2\epsilon$-optimizing with \(\epsilon= \|q-q^*\|_\infty\) and thus</p> </li> </ol> \[v^\pi \ge v^* - \frac{2\|q-q^*\|_\infty}{1-\gamma} \boldsymbol{1}\,.\] <hr /> <p>For the proof, which is partially left to the reader, we need to introduce a bit more notation. In particular, for a memoryless policy, define the operator $M_\pi: \mathbb{R}^{\mathcal{S}\times \mathcal{A}} \to \mathbb{R}^{\mathcal{S}}$:</p> \[(M_\pi q)(s) = \sum_{a\in \mathcal{A}} \pi(a|s) q(s,a)\,, \qquad (q\in \mathbb{R}^{\mathcal{S}\times \mathcal{A}}, \, \, s\in \mathcal{S}).\] <p>With the help of this operator the condition that $\pi$ is greedy with respect to $q$ can be written as</p> \[M_\pi q = M q\,.\] <p>Further, the second claim of the lemma can be stated in the more concise form $M_\pi q^* \ge v^* - 2\epsilon\boldsymbol{1}$.</p> <p>For future reference, we will also find it useful to define $P_\pi: \mathbb{R}^{\mathcal{S}\times \mathcal{A}} \to \mathbb{R}^{\mathcal{S}\times \mathcal{A}}$:</p> \[P_\pi = P M_\pi\,.\] <p>Note that here we abused notation as $P_\pi$ has already been used to denote the operator that maps functions of the states to functions of the state. From the context, the meaning of $P_\pi$ will always be clear.</p> <p><strong>Proof:</strong> The first part of the proof is standard and is left to the reader. For the second part note that</p> \[\begin{align*} M_\pi q^* &amp; \ge M_\pi(q-\epsilon \boldsymbol{1}) = M_\pi q - \epsilon\boldsymbol{1}=M q - \epsilon \boldsymbol{1} \ge M(q^* - \epsilon \boldsymbol{1}) - \epsilon \boldsymbol{1} = M q^* - 2\epsilon \boldsymbol{1} = v^* - 2\epsilon\boldsymbol{1}\,. \end{align*}\] <p>Then use the first part. \(\qquad \blacksquare\)</p> <h3 id="suboptimality-of-almost-epsilon-optimizing-policies">Suboptimality of almost $\epsilon$-optimizing policies</h3> <p>There are two issues that need to be taken care of. One is that the planner is randomizing when computing the values $Q_H(s_0,\cdot)$. What happens when the random next states obtained from the simulator are not “representative”? We cannot expect the outcome of this randomized computation to be precise! Indeed, the best we can expect is that the outcome is “accurate” with some probability, hopefully close to one. In fact, from Hoeffding’s inequality, we see that if we want to achieve small errors in the computation for some target probability, we need to increase the sample size. But Hoeffding’s inequality, in all cases, allows errors which are uncontrolled on some <strong>failure event</strong>.</p> <p>All in all, the best we can hope for is that with each call, $Q_H(s_0,\cdot)$ is a good approximation to \(q^*(s_0,\cdot)\) outside of some “failure event” $\mathcal{F}$ whose probability we will control separately. Let us say the probability of $\mathcal{F}$ is at most $\zeta$:</p> \[\mathbb{P}_{s_0}(\mathcal{F})\le \zeta\,.\] <p>Here, $\mathbb{P}_{s_0}$ denotes the probability measure induced by the interaction of the planner and the MDP simulator on an appropriate probability space. We will choose $\mathcal{F}$ so that on $\mathcal{F}^c$, the complementer of $\mathcal{F}$ (a “good” event), it holds that</p> \[\begin{align} \delta_H = \| Q_H(s_0,\cdot) - q^*(s_0,\cdot)\|_\infty \le \epsilon\,. \label{eq:d0def} \end{align}\] <p>Then, on $\mathcal{F}^c$,</p> \[q^*(s_0, A) \ge Q_H(s_0,A)-\epsilon = \max_a Q_H(s_0,a)-\epsilon \ge \max_a (q^*(s_0,a)-\epsilon)-\epsilon = v^*(s_0)-2\epsilon\,.\] <p>That is, on the good event $\mathcal{F}^c$, the action $A$ returned by the planner is $2\epsilon$ optimizing at state $s_0$.</p> <p>Let $\hat \pi(a \vert s_0)$ denote the probability that action $A$ returned by the planner is $a$: \(\hat \pi(a \vert s_0)=\mathbb{P}_{s_0}(A=a)\). Then,</p> \[\begin{align*} \sum_{a} &amp; \hat \pi(a \vert s_0) \mathbb{I}( q^*(s_0, a) \ge v^*(s_0) - 2\epsilon ) \\ &amp; = \mathbb{P}_{s_0}( q^*(s_0, A) \ge v^*(s_0) - 2\epsilon )\\ &amp;= \mathbb{P}_{s_0}( q^*(s_0, A) \ge v^*(s_0) - 2\epsilon, \mathcal{F}^c ) + \mathbb{P}_{s_0}( q^*(s_0, A) \ge v^*(s_0) - 2\epsilon, \mathcal{F} )\\ &amp;\ge \mathbb{P}_{s_0}( q^*(s_0, A) \ge v^*(s_0) - 2\epsilon, \mathcal{F}^c )\\ &amp;= \mathbb{P}_{s_0}( \mathcal{F}^c )\\ &amp;\ge 1-\zeta\,. \end{align*}\] <p>In words, with probability at least $1-\zeta$, $\hat \pi$ chooses $2\epsilon$-optimizing actions: The policy is <strong>almost $2\epsilon$-optimizing</strong>. While this is not as good as always choosing $2\epsilon$-optimizing actions, we expect that as $\zeta\to 0$ the difference in performance between $\hat \pi$ and a policy that always chooses $2\epsilon$-optimizing actions disappears because performance is expected to depend on action probabilities in a <strong>continuous</strong> fashion. The next lemma makes this precise:</p> <hr /> <p><strong>Lemma (Policy error bound II):</strong> Let $\zeta\in [0,1]$, $\pi$ be a memoryless policy that selects $\epsilon$-optimizing actions with probability at least $1-\zeta$ in each state. Then,</p> \[v^\pi \ge v^* - \frac{\epsilon+2\zeta \|q^*\|_\infty}{1-\gamma} \boldsymbol{1}\,.\] <hr /> <p><strong>Proof:</strong> By Part 1 of the <a href="/lecture-notes/planning-in-mdps/lec6#lem:averror">previous lemma</a>, it suffices to show that $\pi$ is \(\epsilon+2\zeta \|q^*\|_\infty\)-optimizing in every state. This follows from algebra and is left to the reader. \(\qquad \blacksquare\)</p> <h2 id="error-control">Error control</h2> <p>What remains is to show that with high probability, the error $\delta_H$, defined in \(\eqref{eq:d0def}\) is small. Intuitively, $\hat T \approx T$. To firm up this intuition, we may note that for any fixed $q\in \mathbb{R}^{\mathcal{S}\times \mathcal{A}}$ function over the state-action pairs such that \(\|q\|_\infty \le \frac{1}{1-\gamma}\) and for any fixed $(s,a)\in \mathcal{S}\times \mathcal{A}$, by Eq. \(\eqref{eq:hoeffbop}\) and the choice of the sets $\mathcal{C}(s,a)$, with probability $1-\zeta$,</p> \[\begin{align} |\hat T q (s,a)-T q(s,a)| &amp; = \gamma \left| \frac1m \sum_{s'\in \mathcal{C}(s,a)} v(s')\,\, - \langle P_a(s), v \rangle \right| \le \gamma \|q\|_\infty\, \sqrt{\frac{\log \frac{2}{\zeta}}{2m} } \nonumber \\ &amp;\le \frac{\gamma}{1-\gamma}\, \sqrt{\frac{\log \frac{2}{\zeta}}{2m} } =: \Delta(\zeta,m), \label{eq:basicerror} \end{align}\] <p>where, for brevity, we introduced $v = Mq$ in the above formula.</p> <h3 id="union-bounds">Union bounds</h3> <p>So we know that for any <em>fixed</em> state-action pair $(s,a)$, outside of a low probability event, $(\hat T q)(s,a)$ is close to $( T q)(s,a)$. But can we conclude from this that, outside of <em>some</em> low probability event, $(\hat T q)(s,a)$ is close to $( T q)(s,a)$ <em>everywhere</em>?</p> <p>To answer this question, it will be easier to turn it around and just try to come up with some event that, on the one hand, has low probability, while, in the other hand, outside of this event, $(\hat T q)(s,a)$ is close to $( T q)(s,a)$ regardless of $(s,a)$.</p> <p>Denoting by $\mathcal{E}(s,a)$ the event when $(\hat T q)(s,a)$ is <em>not</em> close to $( T q)(s,a)$, i.e.,</p> \[\mathcal{E}(s,a) = \{ |(\hat T q)(s,a) - (Tq)(s,a)|&gt; \Delta(\zeta,m) \}\,,\] <p>it is clear that if $\mathcal{E} = \cup_{(s,a)} \mathcal{E}(s,a)$ then outside of $\mathcal{E}$, none of $\mathcal{E}(s,a)$ holds and hence</p> \[\max_{(s,a)\in \mathcal{S}\times \mathcal{A}} |(\hat T q)(s,a) - (T q)(s,a)|\le \Delta(\zeta,m)\,.\] <p>But how large can the probability of $\mathcal{E}$ be? For this, recall the following elementary result, which follows directly from the properties of measures:</p> <hr /> <p><strong>Lemma (<a href="https://en.wikipedia.org/wiki/Boole%27s_inequality">Union Bound</a>):</strong> For any probability measure $\mathbb{P}$ and any countable sequence of events \(A_1, A_2, \ldots\) of the underlying measurable space,</p> \[\mathbb{P}\left(\cup_i A_i \right) \leq \sum_i \mathbb{P}(A_i).\] <hr /> <p>By this result, using that $\mathcal{S}\times \mathcal{A}$ is finite,</p> \[\mathbb{P}(\mathcal{E}) \le \sum_{(s,a)\in \mathcal{S}\times \mathcal{A}} \mathbb{P}( \mathcal{E}(s,a)) \le \mathrm{S} \mathrm{A} \zeta\,.\] <p>If we want this probability to be $0\le \zeta’\le 1$, we can set $\zeta = \frac{\zeta’}{\mathrm{S}\mathrm{A}}$ and conclude that with probability $1-\zeta’$, for <em>any</em> state-action pair $(s,a)\in \mathcal{S}\times \mathcal{A}$,</p> \[\begin{align} |(\hat T q)(s,a) - (T q)(s,a)| \le \Delta\left(\frac{\zeta'}{\mathrm{S}\mathrm{A}},m\right) = \frac{\gamma}{1-\gamma} \, \sqrt{\frac{\log \frac{2\mathrm{S}\mathrm{A}}{\zeta'}}{2m} }\,. \label{eq:ropec} \end{align}\] <p>The following diagram summarizes the idea of union bounds:</p> <p class="center"><img src="/documents/images/union_bound.png" alt="Union Bound" /></p> <p>To control the error of some bad event happening, we can break the the bad event into a number of elementary parts. By controlling the probability of each such part, we can control the probability of the bad event, or, alternatively, control the probability of the complementary “good” event. The worst case for controlling the probability of the bad event is if the elementary parts do not overlap, but the argument of course works even in this case.</p> <p>Returning to our calculations, from the last formula we see that the errors grew a little compared to \(\eqref{eq:basicerror}\), but the growth is modest: the errors scale with the logarithm of the number of state-action pairs. While this logarithmic error-growth is mild, it is unfortunate that the number of states appears here. To control the errors, by this formulae we would need to choose $m$ to be proportional to the logarithm of the size of the state space, which is better than a linear dependence, but still. One must wonder whether this dependence is truly necessary? If it was, there would be a big gap between the complexity of planning in deterministic and stochastic MDPs. We should not give in for this just yet!</p> <h3 id="avoiding-dependence-on-state-space-cardinality">Avoiding dependence on state space cardinality</h3> <p>The key to avoiding the dependence on the cardinality of the state is to avoid taking union bounds over the whole state-action set. That this may be possible follows from that, thinking back to the recursive implementation of the planner, we can notice that the planner does not necessarily rely on <em>all</em> the sets $\mathcal{C}(s,a)$.</p> <p>To get a handle on this, it will be useful to introduce a notion of a distance induced by the set $\mathcal{C}(s):=\cup_{a\in \mathcal{A}}\mathcal{C}(s,a)$ between the states. This distance between states $s$ and $s’$ (denoted by $\text{dist}(s,s’)$) will be the smallest number of steps that we can take to get from $s$ to $s’$, if in each step we choose one “neighbouring” state to the last state, starting from state $s$. Formally, this is the length $n$ of the shortest sequence $s_0,s_1,\dots,s_n$ such that $s_0=s$, $s_n = s’$ and for each $i\in [n]$, $s_i \in \mathcal{C}(s_{i-1})$ (this is the distance between states in the directed graph over the states with edges induced by $\mathcal{C}$).</p> <p>With this, for $h\ge 0$, define</p> \[\begin{align*} \mathcal{S}_h &amp;= \{s \in \mathcal{S} | \text{ dist}(s_0,s) \leq h \} \end{align*}\] <p>as the set of states accessible from $s_0$ by at most $h$ steps. Note that this is a nested sequence of sets and $\mathcal{S}_0 = {s_0}$, $\mathcal{S}_1$ contains $s_0$ and its immediate “neighbors”, etc.</p> <p>We may now observe that in the calculation of $Q_H(s_0,\cdot)$ when function $q$ is called with a certain value of $0\le k \le H$, for the state that appears in the call we have</p> \[s\in \mathcal{S}_{H-k}\,.\] <p>This can be proved by induction on $k$, starting with $k=H$.</p> <details><summary>Click here for the proof.</summary> The base case follows because when $q$ calls itself it decrements $k$. Hence, when $q$ is called with $k=H$ and state $s$, $s=s_0$ must be true. Hence, $s\in \mathcal{S}_0$. Now, assume that the claim holds for $k=i+1$ with some $0\le i&lt; H$. Take any state $s'$ that $q$ is called on while $k=i$. Since $i&lt;H$, this call must be a recursive call (from line 3). Going up on the call chain, at the time this recursive call is made, $k=i+1$ (since in the recursive calls the value of $k$ is decremented). This call happens when $s'\in \mathcal{C}(s,a)$ for some action $a\in \mathcal{A}$ and some state $s$, which, by the induction hypothesis, satisfies $s\in \mathcal{S}_{H-(i+1)}$. It follows that $s$ is at a distance of at most $H-i-1$ from $s_0$, while $s'$, a "neighbour" of $s$, is at most of a distance of $H-i-1+1=H-i$ from $s_0$. Hence, $s\in \mathcal{S}_{H-i}$, finishing the induction. $$\blacksquare$$ </details> <p>Taking into account that when $q$ is called with $k=0$, the sets $\mathcal{C}(s,a)$ are not used (line 2), we see that only states $s$ from $\mathcal{S}_{H-1}$ are such that the calculation ever uses the set $\mathcal{C}(s,a)$. Since $|\mathcal{C}(s,a)|=m$,</p> \[\mathcal{S}_h \le 1 + (mA) + \dots + (mA)^h \le (mA)^{h+1}\] <p>and in particular, $\mathcal{S}_{H-1}\le (mA)^H$, which is independent of the size of the state space. Of course, all along, we knew this very well: This is why the total runtime is also independent of the size of the state space.</p> <p>The plan is to take advantage of this to avoid a union bound over all possible state-action pairs. We start with a recursive expression for the errors.</p> <p>Recall that \(\delta_H = \| (\hat T^H \boldsymbol{0})(s_0,\cdot)-q^*(s_0,\cdot)\|_\infty\). By the triangle inequality,</p> \[\begin{align*} \delta_H &amp; = \| (\hat T^H \boldsymbol{0})(s_0,\cdot)-q^*(s_0,\cdot)\|_\infty \le \| (\hat T \hat T^{H-1} \boldsymbol{0})(s_0,\cdot)- \hat T q^*(s_0,\cdot)\|_\infty + \| \hat T q^*(s_0,\cdot)- q^*(s_0,\cdot)\|_\infty\,. \end{align*}\] <p>Now, observing that</p> \[\vert \hat T q (s,a)-\hat T q^* (s,a) \vert \le \frac{\gamma}{m} \sum_{s'\in \mathcal{C}(s,a)} \vert Mq - v^* \vert (s') \le \gamma \max_{s'\in \mathcal{C}(s)} \vert Mq - v^* \vert (s')\,,\] <p>we see that</p> \[\begin{align*} \delta_H &amp; \le \gamma \max_{s'\in \mathcal{C}(s_0),a\in \mathcal{A}} | (\hat T^{H-1} \boldsymbol{0})(s',a)-q^*(s',a) | + \| \hat T q^*(s_0,\cdot)- q^*(s_0,\cdot)\|_\infty\,. \end{align*}\] <p>In particular, defining</p> \[\delta_{h} = \underbrace{\max_{s'\in \mathcal{S}_{H-h},a\in \mathcal{A}} | \hat T^{h} \boldsymbol{0}(s',a)-q^*(s',a)|}_{=:\| \hat T^h \boldsymbol{0}-q^*\|_{\mathcal{S}_{H-h}}}\,,\] <p>we see that</p> \[\delta_H \le \gamma \delta_{H-1} + \| \hat T q^* - q^* \|_{\mathcal{S}_0}\,,\] <p>where we use the notation \(\| q \|_{\mathcal{U}} = \max_{s\in \mathcal{U},\max_{a\in \mathcal{A}}} |q(s,a)|\). More generally, we can prove by induction on $1\le h \le H$ (starting with $h=H$) that</p> \[\delta_h \le \gamma \delta_{h-1} + \| \hat T q^* - q^* \|_{\mathcal{S}_{H-h}} \le \gamma \delta_{h-1} + \underbrace{ \| \hat T q^* - q^* \|_{\mathcal{S}_{H-1}}}_{=:\varepsilon'/(1-\gamma)} \,,\] <p>while</p> \[\delta_0 = \| q^*\|_{\mathcal{S}_{H}} \le \| q^* \|_\infty \le \frac{1}{1-\gamma}\,,\] <p>where the last inequality uses that $r_a(s)\in [0,1]$, which we shall assume for simplicity. Unfolding this recursion for $(\delta_h)_h$, letting</p> <p>we get</p> \[\begin{align} \delta_H &amp;\leq \frac{\gamma^H + \varepsilon'(1 + \gamma + \cdots + \gamma^{H-1})}{1 - \gamma} \leq \left(\gamma^H + \frac{\varepsilon'}{1 - \gamma} \right) \frac{1}{1 - \gamma} \label{eq:delta_H}. \end{align}\] <p>We see that the first term in the sum on the right-hand side (in the parenthesis) is controlled by $H$. It remains to show that $\varepsilon’$ can also be controlled (by choosing $m$ appropriately).</p> <p>In fact, notice that $\varepsilon’ / (1 - \gamma)$ is the maximum-norm error with which \(\hat T q^*\) approximates \(q^* = T q^*\), but only for states in \(\mathcal{S}_{H-1}\) we need to control this error. By our earlier argument, this set has at most \((mA)^H\) states, hence, it is believable that this error can be controlled even when $m$ is chosen independently of the number of states.</p> <h3 id="controlling--hat-t-q---q-_mathcals_h-1">Controlling \(\| \hat T q^* - q^* \|_{\mathcal{S}_{H-1}}\)</h3> <p>Since \(\mathcal{S}_{H-1}\) has only $(mA)^H$ states in it, one’s first instinct is to take a union bound over the error events for the states in this set. The trouble is that the set \(\mathcal{S}_{H-1}\) itself is random. As such, it is not clear, what the failure events should be? And how many failure events are we going to have? The size of this set is also random! Notice that if \((A_i)_{i\in [n]}\) are some events with \(\mathbb{P}(A_i)\le \delta\) and \(I_1,\dots,I_k\in [n]\) are random indices, it does not hold that \(\mathbb{P}( \cup_{j=1}^k A_{I_j}) \le k \delta\): One cannot apply the union bound to randomly chosen events. In fact, in the worst case, \(\mathbb{P}( \cup_{j=1}^k A_{I_j}) = n \delta\).</p> <p>To exploit that \(\mathcal{S}_{H-1}\) is a small set, we need to use one more time the structure. The reason that the randomness of \(\mathcal{S}_{H-1}\) is not going to matter too much is because of the special way this set is constructed. First of all, clearly, \(s_0\in \mathcal{S}_{H-1}\) always and at this state the error \(\|(\hat T q^*)(s_0,\cdot)- Tq^*(s_0,\cdot)\|_\infty\) is under control by Hoeffding’s inequality. Next, we may consider the neighbors of \(s_0\). If \(S\in \mathcal{C}(s_0)\), either \(S=s_0\), in which case we already know that the error at \(S\) is under control, or \(S\) is a “bona fide neighbor” and we can think of then generating the elements in \(\mathcal{C}(S,a)\) just inside the call of $q$. Ultimately, the error at such a neighbor is under control because, by definition, all the sets \(\mathcal{C}(s,a)\) (with $(s,a)$ sweeping through all possible state-action pairs) are <strong>independently chosen</strong>.</p> <p>This suggests that we should consider the chronological order in which in the recursive call of function $q$ the states in \(\mathcal{S}_{H-1}\) appear. Let this order be $S_1,S_2,\dots,S_n$, where $n = 1+(mA)+\dots+(mA)^{H-1}$, $S_1=s_0$, $S_2$ is the second state that $q$ is called on (necessarily, \(S_2\in \mathcal{C}(s_0)\)), \(S_3\) is the third such state. Note that states may reappear in this sequence multiple times. Furthermore, by construction, \(\mathcal{S}_{H-1} = \{ S_1,\dots,S_n \}\). Also note that the length of this sequence is not random: This length is exactly the number of times $q$ is called, which is clearly not random.</p> <p>That \(\| \hat T q^* - q^* \|_{\mathcal{S}_{H-1}}=\| \hat T q^* - Tq^* \|_{\mathcal{S}_{H-1}}\) is under control directly follows from the next lemma:</p> <hr /> <p><strong>Lemma:</strong> Assume that the immediate rewards belong to the $[0,1]$ interval. For any $0\le \zeta \le 1$ with probability $1-\mathrm{A}n\zeta$, for any $1\le i \le n$,</p> \[\begin{align*} \| \hat T q^* (S_i, \cdot)- q^* (S_i,\cdot) \|_{\infty} \le \Delta(\zeta,m)\,, \end{align*}\] <p>where \(\Delta\) is given by \(\eqref{eq:basicerror}\).</p> <hr /> <p><strong>Proof:</strong> Recall that $\mathcal{C}(s,a) = (S_1’(s,a),\dots,S_m’(s,a))$ where <em>(i)</em> the \((\mathcal{C}(s,a))_{(s,a)}\) are mutually independent and <em>(ii)</em> for any $(s,a)$, $(S_i’(s,a))_i$ is an i.i.d. sequence with common distribution $P_a(s)$.</p> <p>For \(s\in \mathcal{S}\), \(a\in \mathcal{A}\), \(C\in \mathcal{S}^m\), let</p> \[\begin{align*} g(s,a,C) =| \frac{\gamma}{m} \sum_{s'\in C} v^*(s') \,\, - \langle P_a(s), v^* \rangle | \end{align*}\] <p>(as earlier, $s’\in C$ means that $s’$ is an element of the set composed of the elements in the sequence $C$). Recall that by the definition of $\hat T$ and the properties of $q^*$,</p> \[\begin{align} |\hat T q^*(s,a)- q^*(s,a)| = | \frac{\gamma}{m} \sum_{s'\in \mathcal{C}(s,a)} v^*(s') \,\, - \langle P_a(s), v^* \rangle | = g(s,a,\mathcal{C}(s,a)) \,. \label{eq:dub} \end{align}\] <p>Fix \(1 \le i \le n\). Let \(\tau = \min\{ 1\le j \le i\,:\, S_j = S_i \}\). That is, $\tau$ is the time when $S_i$ first appears in the sequence \(\{S_i\}_i\).</p> <p>Fix $a\in \mathcal{A}$. We claim that given \(S_{\tau}\), \((S_j'(S_{\tau},a))_{j=1}^m\) is i.i.d. with common distribution \(P_a(S_{\tau})\). That is, for any \(s,s_1',\dots,s_m'\in \mathcal{S}\),</p> \[\begin{align} \mathbb{P}( S_1'(S_{\tau},a)=s_1',\dots, S_m'(S_{\tau},a)=s_m' \, \vert\, S_{\tau}=s) = \prod_{j=1}^m P(s,a,s_j') \label{eq:indep} \end{align}\] <p>Note that given this, for any $\Delta\ge 0$, by \(\eqref{eq:dub}\),</p> \[\begin{align*} \mathbb{P}( &amp; |\hat T q^*(S_i,a)- q^*(S_i,a)| &gt; \Delta ) = \mathbb{P}( g(S_i,a,\mathcal{C}(S_i,a)) &gt; \Delta ) \\ &amp; = \mathbb{P}( g(S_{\tau},a,\mathcal{C}(S_\tau,a)) &gt; \Delta ) \\ &amp; = \sum_{s} \mathbb{P}( g(s,a,\mathcal{C}(s,a)) &gt; \Delta, S_{\tau}=s ) \\ &amp; = \sum_{s} \sum_{1\le j \le i} \mathbb{P}( g(s,a,\mathcal{C}(s,a)) &gt; \Delta, S_j=s, \tau=j ) \\ &amp; = \sum_{s} \sum_{1\le j \le i} \sum_{\substack{s_{1:j-1} \in \mathcal{S}^{j-1}:\\ s\not\in s_{1:j-1}}} \mathbb{P}( g(s,a,\mathcal{C}(s,a)) &gt; \Delta, S_j=s, S_{1:j-1}=s_{1:j-1})\\ &amp; = \sum_{s} \sum_{1\le j \le i} \sum_{\substack{s_{1:j-1} \in \mathcal{S}^{j-1}:\\ s\not\in s_{1:j-1}}} \mathbb{P}( g(s,a,\mathcal{C}(s,a)) &gt; \Delta, \phi_j( s,s_{1:j-1},\mathcal{C}(s_1),\dots,\mathcal{C}(s_{j-1}) )=1 )\,, \end{align*}\] <p>for some binary valued functions $\phi_1$, $\dots$, $\phi_i$ where for $1\le j \le i$, $\phi_j$ is defined so that</p> \[\phi_j( s,s_{1:j-1},\mathcal{C}(s_1),\dots,\mathcal{C}(s_{j-1}) )=1\] <p>holds if and only if $S_j=s, S_{1:j-1}=s_{1:j-1}$ holds, where $s\in \mathcal{S}$ and $s_{1:j-1}\in \mathcal{S}^{j-1}$ are arbitrary so that $s\not\in s_{1:j-1}$. That such functions exist follows because for any sequence $s_{1:j}$ to verify whether $S_{1:j}=s_{1:j}$ the knowledge of the sets $\mathcal{C}(s_1),\dots,\mathcal{C}(s_{j-1})$ suffices: The appropriate function should first check $S_1=s_1$, then move on to checking $S_2=s_2$ only if $S_1=s_1$ holds, etc.</p> <p>Now, notice that by our assumptions, for $s\not\in s_{1:j-1}$, $\mathcal{C}(s,a)$ and $\phi_j( s,s_{1:j-1},\mathcal{C}(s_1),\dots,\mathcal{C}(s_{j-1}) )=1$ are independent of each other. Hence,</p> \[\begin{align*} \mathbb{P}( &amp; g(s,a,\mathcal{C}(s,a)) &gt; \Delta, \phi_j( s,s_{1:j-1},\mathcal{C}(s_1),\dots,\mathcal{C}(s_{j-1}) )=1 )\\ &amp; = \mathbb{P}( g(s,a,\mathcal{C}(s,a)) &gt; \Delta) \cdot \mathbb{P}(\phi_j( s,s_{1:j-1},\mathcal{C}(s_1),\dots,\mathcal{C}(s_{j-1}) )=1 )\,. \end{align*}\] <p>Plugging this back into the previous displayed equation, “unrolling” the expansion done using the law of total probability, we find that</p> \[\begin{align*} \mathbb{P}( |\hat T q^*(S_i,a)- q^*(S_i,a)| &gt; \Delta ) &amp; = \sum_{s} \mathbb{P}( g(s,a,\mathcal{C}(s,a)) &gt; \Delta ) \mathbb{P}( S_\tau = s )\,. \end{align*}\] <p>Now, choose $\Delta = \Delta(\zeta,m)$ from \(\eqref{eq:basicerror}\) so that, thanks to $|q^*|_\infty \le 1/(1-\gamma)$, for any fixed $(s,a)$, \(\mathbb{P}( g(s,a,\mathcal{C}(s,a)) &gt; \Delta(\zeta,m) )\le \zeta\) Plugging this in into the previous display we get</p> \[\begin{align*} \mathbb{P}( |\hat T q^*(S_i,a)- q^*(S_i,a)| &gt; \Delta(\zeta,m) ) \le \zeta \sum_{s} \mathbb{P}( S_\tau = s ) = \zeta\,. \end{align*}\] <p>The claim the follows by a union bound over all actions and all $1\le i \le n$. \(\qquad \blacksquare\)</p> <h2 id="final-error-bound">Final error bound</h2> <p>Putting everything together, we get that for any $0\le \zeta \le 1$, the policy $\hat \pi$ induced by the planner is $\epsilon(m,H,\zeta)$-optimal with</p> \[\epsilon(m,H,\zeta):=\frac{2}{(1-\gamma)^2} \left[\gamma^H + \frac{1}{1-\gamma} \sqrt{ \frac{\log\left(\frac{2n\mathrm{A}}{\zeta}\right)}{2m} } + \zeta \right]\,.\] <p>Thus, to obtain a planner that induces a $\delta$-optimal policy, we can set $H$, $\zeta$ and $m$ so that each term above contributes at most $\delta/3$:</p> \[\begin{align*} \frac{2\gamma^H}{1-\gamma} &amp; \le (1-\gamma)\frac{\delta}{3}\,,\\ \zeta &amp; \le (1-\gamma)^2\frac{\delta}{6}\, \qquad \text{and}\\ \frac{m}{\log\left(\frac{2n\mathrm{A}}{\zeta}\right)} &amp; \ge \frac{18}{\delta^2(1-\gamma)^6}\,. \end{align*}\] <p>For $H$ we get that we can set $H = \lceil H_{\gamma,(1-\gamma)\delta/6}\rceil$. We can also set $\zeta = (1-\gamma)^2\delta/6$. To solve for the smallest $m$ that satisfies the last inequality, recall that $n = (mA)^H$. To find the critical value of $m$ note the following elementary result which we cite without a proof:</p> <hr /> <p><strong>Proposition:</strong> Let $a&gt;0$, $b\in \mathbb{R}$. Let \(t^*=\frac{2}{a}\left[ \log\left(\frac1a\right)-b \right]\). Then, for any positive real $t$ such that $t\ge t^*$,</p> \[\begin{align*} at+b &gt; \log(t)\,. \end{align*}\] <hr /> <p>From this, defining</p> \[c_\delta = \frac{18}{\delta^2(1-\gamma)^6}\] <p>and</p> \[\begin{align} m^*(\delta,\mathrm{A}) = 2c_\delta \left[ H \log(c_\delta H) + \log\left(\frac{12}{(1-\gamma)^2\delta}\right) + (H+1) \log(\mathrm{A}) \right] \label{eq:mstar} \end{align}\] <p>if $m \ge m^*$ then all the inequalities are satisfied. Putting things together, we thus get the following result:</p> <hr /> <p><strong>Theorem:</strong> Assume that the immediate rewards belong to the $[0,1]$ interval. There is an online planner such that for any $\delta\ge 0$, in any discounted MDP with discount factor $\gamma$, the planner induces a $\delta$-optimal policy and uses at most \(O( (m^* \mathrm{A})^H )\) elementary arithmetic and logic operations per its calls, where $m^*(\delta,\mathrm{A})$ is given by \(\eqref{eq:mstar}\) and $H = \lceil H_{\gamma,(1-\gamma)\delta/3}\rceil$.</p> <hr /> <p>Overall, we see that the runtime did increase compared to the deterministic case (apart from logarithmic factors, in the above result $m = H^7/\delta^2$ whereas in the deterministic case $m=1$!), but we managed to get a runtime that is independent of the cardinality of the state space. Again, what is troubling is the <strong>exponential dependence</strong> on the effective horizon, though as we have seen, in the worst-case, this is unavoidable. In the next lectures we will consider proving the planner with extra information so that this exponential dependence can be avoided.</p> <h2 id="notes">Notes</h2> <h3 id="sparse-lookahead-trees">Sparse lookahead trees</h3> <p>The idea of the algorithm that we analyzed comes from a paper by <a href="#ref:KMN02">Kearns, Mansour and Ng from 2002</a>. In their paper they consider the version of the algorithm which creates a fresh “new” random set $\mathcal{C}(s,a)$ in <em>every</em> recursive call. This makes it harder to see their algorithm as approximating the Bellman operator, but in effect, the two approaches are by and large the same. In fact, if we introduce $H$ random operators, $\hat T_1$, $\dots$, $\hat T_H$ which are the same as $\hat T$ above but $\hat T_h$ has its own “private” sets $( \hat C_h(s,a) )_{(s,a)}$, then their algorithm can be written as computing</p> \[A = \arg\max_{a} (\hat T_1 \dots \hat T_h \boldsymbol{0})(s_0,a)\,.\] <p>It is not hard to modify the analysis given here to accommodate this change. With this, one can also interpret the calculations done by the algorithm as backing up values in a “sparse lookahead tree” built recursively from $s_0$.</p> <p>Much work has been devoted to improving these basic ideas and eventually these ideas led to various Monte-Carlo tree search algorithms, including yours truly’s UCT. In general, these algorithms attempt to improve on the runtime by building the trees when they need to be built. As it turns out, a useful strategy here is to expand nodes which in a way hold the greatest promise to improve the value at the “root”. This is known as the “optimisism in planning”. Note that A* (and its MDP relative, AO<em>) are also based on optimism: A</em>’s admissible heuristic functions in our language correspond to functions that upper bound the optimal value. The definite source on MCTS theory as of today is <a href="https://www.nowpublishers.com/article/Details/MAL-038">Remi Munos’s monograph</a>.</p> <h3 id="measure-concentration">Measure concentration</h3> <p>Hoeffding’s inequality is a special case of what is known as measure concentration. This phrase refers to that the empirical measure induced by a sample is a good approximation to the whole measure. The simplest case is when one just compares the means of the measures (the empirical and the sample-generating one), giving rise to concentration inequalities around the mean. Hoeffding’s inequality is an example. What we like about Hoeffding’s inequality (besides that it is simple) is that the failure probability, $\delta$ (later $\zeta$) appears inside a logarithm. That means, that the price of being more stringent is mild. When the exact dependence is of type that appears in Hoeffding’s inequality (i.e., $\sqrt{ \log(1/\delta)})$), we say that the deviation of the subgaussian type because Gaussian random variables also satisfy an inequality like this. Concentration of measure and concentration inequalities are a central topic in probability theory, with separate books devoted to them. A few favourites are given at the end of this notes . For learning purposes, Pollard’s mini-book is nice (but all these books have pros and cons), or Vershynin’s book.</p> <h3 id="the-comparison-inequality">The comparison inequality</h3> <p>The comparison inequality between the logarithm and the linear function is given as Proposition 4 <a href="https://sites.ualberta.ca/~szepesva/papers/Allocation-TCS10.pdf">here</a>. The proof is based on two observations: First, it is enough to consider the case when $b=0$. Then, if $a\ge 1$, the result is trivial, while for $a&lt; 1$, the guess is based on doubling the value where the growth rate of $t\mapsto at$ matches that of $t\mapsto \log(t)$.</p> <h3 id="a-model-centered-view-and-random-operators">A model-centered view and random operators</h3> <p>A key idea of this lecture is that $\hat T$ is a good (random) approximation to $T$, hence, it can be used in place of $T$. One can also tell this story by saying that the data underlying $\hat T$ gives a random approximation to the MDP; the transition probabilities of this random approximating MDP would be defined using</p> \[\hat P(s,a,s') = \frac1m \sum_{s''\in C(s,a)} \mathbb{I}\{ s''=s'\}\] <p>It may seem quite miraculous that with only a few elements in $C(s,a)$ (i.e., small $m$) we get a good approximation to the next state distribution. But so is the magic of randomness! Using a random operator (or a sequence of them, if, as outlined above, one uses a fresh set of random next state every time an update is calculated) in a dynamic programming method has been coined <em>empirical dynamic programming</em> by <a href="#ref:haskell">Haskell et al.</a>.</p> <p class="center"><em>A bigger point is that for a model to be a “good” approximation to the “true MDP”, it suffices that the Bellman optimality operator that it induces is a “close” approximation to the Bellman optimality operator of the true MDP.</em></p> <p>This in fact brings us to our next topic, which is what happens when the simulator is imperfect?</p> <h3 id="imperfect-simulation-model">Imperfect simulation model?</h3> <p>We can rarely expect simulators to be perfect. Luckily, not all is lost in this case. As noted above, if the simulator induced an MDP whose Bellman optimality operator is in a way close to the Bellman optimality operator of the true MDP, we expect the outcome of planning to be still a good policy in the true MDP.</p> <p>In fact, the above proof has already all the key elements in place to show this. In particular, it is not hard to show that if $\hat T$ is a $\gamma$ max-norm contraction and $\hat q^*$ is its fixed point then</p> \[\|\hat q^* - q^*\|_\infty \le \frac{\| \hat T q^* - T q^* \|_\infty}{1-\gamma}\,,\] <p>which, combined with the our <a href="#lem:averror">first lemma</a> of this lecture on the policy error bound gives that the policy that is greedy with respect to $\hat q^*$ is</p> \[\frac{2\| \hat T q^* - T q^* \|_\infty }{(1-\gamma)^2}\] <p>optimal in the MDP underlying $T$. We will return to this in later lectures. In particular, in batch reinforcement learning, one of the basic methods is to learn a “model” of the environment and as such it is inevitable to study the error that results from modelling errors. See <a href="/lecture-notes/batch-rl/lec17/">Lecture 17</a> and <a href="/lecture-notes/batch-rl/lec18/">Lecture 18</a>.</p> <h3 id="monte-carlo-methods">Monte-Carlo methods</h3> <p>We saw in homework 0 that randomization may help a little, and today we saw that it can help in a more significant way. A major lesson again is that representations do matter: If the MDP is not given with a “generative simulator”, getting such a simulator may be really hard. This is good to remember when it comes to learning models:</p> <p class="center"><em>One should insist on learning models that make the job of planners easier.</em></p> <p>Generative models are one such case, provably, as we have seen in today’s lecture put together with our previous lower bound that involved the number of states. Randomization, more generally, is a powerful tool in computing science, which brings us to a somewhat philosophical question: What is randomness? Does “true randomness” exist? Can we really build computers to harness this?</p> <h3 id="true-randomness">True randomness?</h3> <p>What is the meaning of “true” randomness? The margin is definitely not big enough to explain this. Hence, we just leave this there, hanging, for everyone to ponder about. But let’s also note that this is a thoroughly studied question in theoretical computing science, with many beautiful results and even books. Arora and Barak’s <a href="#ref:arorabarak">book</a> on computational complexity (Chapters 7, 20 and 21) is a good start for exploring this.</p> <h3 id="can-we-recycle-the-sets-csa-between-the-calls">Can we recycle the sets $C(s,a)$ between the calls?</h3> <p>If simulation is expensive, it may be tempting to recycle the sets between calls of the planner. After all, even if we recycle these sets, \(\hat{\pi}\) will have the property that it selects $\epsilon$-optimizing actions with high probability at every state. However, this may not be a good idea. The reader is challenged to think about what can go wrong? The proof actually uses that the planner construct a new random operator $\hat T$ with every call. But where is this used?</p> <h3 id="the-ubiquity-of-continuity-arguments-in-the-mdp-literature">The ubiquity of continuity arguments in the MDP literature</h3> <p>All the computations that we do with MDPs tend to be approximate. We evaluate policies approximately. We compute a Bellman back approximately. We have approximate models. We greedify approximately. If any of these operations could enlarge small errors, none of the approximate methods would work. The study of approximate computations (which is a necessity if one faces large MDPs) is a study of the sensitivity of the values of the resulting policies to the errors introduced in the computations. This, in numerical analysis, would be called error analysis. In other areas of mathematics, this is called sensitivity analysis. In fact, sensitivity analysis often involves computing derivatives to see how fast outputs change as the inputs change (which is that data that will be approximated). What should we be taking derivatives with respect to here? Well, it is always the data that is being changed. One can in fact use differentiation based sensitivity analysis everywhere. This has been tried a little in the “older” MDP literature and is also related to policy gradient theorems (that we will learn about laters). However, perhaps there are more nice things to be discovered about this approach.</p> <h3 id="from-local-to-online-access">From local to online access</h3> <p>The algorithm that is analyzed in this lecture requires local access simulators. This is better than requiring global access, but worse than requiring online access. It remains an open question of whether with online access, one can also get a similar result than shown in the present lecture and if not, whether the sample complexity of planning remains finite under this setting.</p> <h3 id="when-the-state-space-is-small">When the state space is small</h3> <p>For finite state-action MDPs where the rewards and transition probabilities are represented using tables, <a href="/lecture-notes/planning-in-mdps/lec4/">a previous lecture’s</a> main result established that an optimal policy of the MDP can be calculated by using at most $O(H\textrm{poly}(S,A))$ arithmetic and logic operations ($H=1/(1-\gamma)$ here). In the current lecture we saw that even when $S$ is unbounded, given a simulator with local access, $\tilde{O}((AH^7/\delta^2)^H)$ such elementary operations and calls to a simulator are sufficient. In a finite MDP, depending on the values of $S,A$ and $H$, either policy iteration, or the online planner that builds the tree will be faster. But policy iteration (and value iteration) as described previously used a table representation. The question then arises of what is the sample complexity of planning with a simulator access to a finite MDP? If planning means outputting a policy, the complexity needs to scale with $S$. In the presence of global access simulators, a simple approach, is to sample an appropriate number of next states for each state-action pair to build an empirical (but “sparse”) transition model and use this in connection with any MDP solver. We will see later in <a href="/lecture-notes/batch-rl/lec18/">Lecture 18</a> that in this case $O(H^3 SA/\delta^2)$ samples (or $H^3/\delta^2$ samples per state-action pair) are sufficient to obtain a $\delta$-optimal policy.</p> <p>In the case of online planning with global access, the sample complexity cannot be worse, but it is unclear whether it can be improved. Similarly, it is unclear what the complexity is in the case of either local or online access.</p> <h2 id="references">References</h2> <ul> <li><a name="ref:KMN02"></a>Kearns, M., Mansour, Y., &amp; Ng, A. Y. (2002). A sparse sampling algorithm for near-optimal planning in large Markov decision processes. Machine learning, 49(2), 193-208. <a href="https://www.cis.upenn.edu/~mkearns/papers/sparsesampling-journal.pdf">[link]</a></li> <li>David Pollard (2015). A few good inequalities. Chapter 2 of a book under preparation with working title “MiniEmpirical”. <a href="http://www.stat.yale.edu/~pollard/Books/Mini/Basic.pdf">[link]</a></li> <li>Stephane Boucheron, Gabor Lugosi and Pascal Massart (2012). Concentration inequalities: A nonasymptotic theory of indepndence. Clarendon Press – Oxford. <a href="https://www.hse.ru/data/2016/11/24/1113029206/Concentration%20inequalities.pdf">[link]</a></li> <li>Roman Vershynin (2018). High-Dimensional Probability: An Introduction with Applications in Data Science. <a href="https://www.math.uci.edu/~rvershyn/papers/HDP-book/HDP-book.html">[link]</a></li> <li>M. J. Wainwright (2019) High-dimensional statistics: A non-asymptotic viewpoint. Cambridge University Press.</li> <li>Lafferty J., Liu H., &amp; Wasserman L. (2010). Concentration of Measure. <a href="http://www.stat.cmu.edu/~larry/=sml/Concentration.pdf">[link]</a></li> <li>Lattimore, T., &amp; Szepesvári, C. (2020). <a href="https://banditalgs.com">Bandit algorithms.</a> Cambridge University Press.</li> <li><a name="ref:haskell"></a>William B. Haskell, Rahul Jain, and Dileep Kalathil. Empirical dynamic programming. Mathematics of Operations Research, 2016.</li> <li><a name="ref:arorabarak"></a> Sanjeev Arora and Boaz Barak (2009). Computational Complexity: A Modern Approach. Cambridge University Press.</li> <li>Remi Munos (2014). From Bandits to Monte-Carlo Tree Search: The Optimistic Principle Applied to Optimization and Planning. Foundations and Trends in Machine Learning: Vol. 7: No. 1, pp 1-129.</li> </ul> <hr> <footer> <p><a href="#top" id="back-to-top">Back to top</a></p> <p class="text-small text-grey-dk-100 mb-0">Copyright &copy; 2024 RL Theory.</p> <div class="d-flex mt-2"> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> </body> </html>

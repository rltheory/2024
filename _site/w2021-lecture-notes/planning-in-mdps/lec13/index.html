<!DOCTYPE html> <html lang="en-US"> <head> <meta charset="UTF-8"> <meta http-equiv="X-UA-Compatible" content="IE=Edge"> <link rel="stylesheet" href="/2024/assets/css/just-the-docs-default.css"> <script src="/2024/assets/js/vendor/lunr.min.js"></script> <script src="/2024/assets/js/just-the-docs.js"></script> <meta name="viewport" content="width=device-width, initial-scale=1"> <link rel="icon" href="/2024/favicon.ico" type="image/x-icon"> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>From API to Politex | RL Theory</title> <meta name="generator" content="Jekyll v4.2.2" /> <meta property="og:title" content="From API to Politex" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="In the lecture on approximate policy iteration, we proved that for any MDP feature-map pair $(M,\phi)$ and any $\varepsilon’&gt;0$ excess suboptimality target, with a total runtime of" /> <meta property="og:description" content="In the lecture on approximate policy iteration, we proved that for any MDP feature-map pair $(M,\phi)$ and any $\varepsilon’&gt;0$ excess suboptimality target, with a total runtime of" /> <link rel="canonical" href="http://localhost:4000/2024/w2021-lecture-notes/planning-in-mdps/lec13/" /> <meta property="og:url" content="http://localhost:4000/2024/w2021-lecture-notes/planning-in-mdps/lec13/" /> <meta property="og:site_name" content="RL Theory" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2024-09-21T14:43:24-06:00" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="From API to Politex" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-21T14:43:24-06:00","datePublished":"2024-09-21T14:43:24-06:00","description":"In the lecture on approximate policy iteration, we proved that for any MDP feature-map pair $(M,\\phi)$ and any $\\varepsilon’&gt;0$ excess suboptimality target, with a total runtime of","headline":"From API to Politex","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2024/w2021-lecture-notes/planning-in-mdps/lec13/"},"url":"http://localhost:4000/2024/w2021-lecture-notes/planning-in-mdps/lec13/"}</script> <!-- End Jekyll SEO tag --> <!-- MathJax --> <!-- http://docs.mathjax.org/en/latest/web/start.html --> <!-- http://docs.mathjax.org/en/latest/web/configuration.html#web-configuration --> <!-- http://docs.mathjax.org/en/latest/options/input/tex.html --> <!-- http://docs.mathjax.org/en/latest/input/tex/eqnumbers.html --> <script> MathJax = { tex: { inlineMath: [['$', '$'], ['\\(', '\\)']], processEscapes: true, tags: 'ams' } }; </script> <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"> </script> <!-- Google fonts --> <!-- https://fonts.google.com/specimen/Merriweather?sidebar.open=true&selection.family=Merriweather:wght@400;900 --> <style> @import url('https://fonts.googleapis.com/css2?family=Merriweather:wght@400;900&display=swap'); </style> </head> <body> <svg xmlns="http://www.w3.org/2000/svg" style="display: none;"> <symbol id="svg-link" viewBox="0 0 24 24"> <title>Link</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-link"> <path d="M10 13a5 5 0 0 0 7.54.54l3-3a5 5 0 0 0-7.07-7.07l-1.72 1.71"></path><path d="M14 11a5 5 0 0 0-7.54-.54l-3 3a5 5 0 0 0 7.07 7.07l1.71-1.71"></path> </svg> </symbol> <symbol id="svg-search" viewBox="0 0 24 24"> <title>Search</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-search"> <circle cx="11" cy="11" r="8"></circle><line x1="21" y1="21" x2="16.65" y2="16.65"></line> </svg> </symbol> <symbol id="svg-menu" viewBox="0 0 24 24"> <title>Menu</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-menu"> <line x1="3" y1="12" x2="21" y2="12"></line><line x1="3" y1="6" x2="21" y2="6"></line><line x1="3" y1="18" x2="21" y2="18"></line> </svg> </symbol> <symbol id="svg-arrow-right" viewBox="0 0 24 24"> <title>Expand</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-chevron-right"> <polyline points="9 18 15 12 9 6"></polyline> </svg> </symbol> <symbol id="svg-doc" viewBox="0 0 24 24"> <title>Document</title> <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-file"> <path d="M13 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V9z"></path><polyline points="13 2 13 9 20 9"></polyline> </svg> </symbol> </svg> <div class="side-bar"> <div class="site-header"> <a href="http://localhost:4000/2024/" class="site-title lh-tight"> RL Theory </a> <a href="#" id="menu-button" class="site-button"> <svg viewBox="0 0 24 24" class="icon"><use xlink:href="#svg-menu"></use></svg> </a> </div> <nav role="navigation" aria-label="Main" id="site-nav" class="site-nav"> <div class="nav-category">Pages</div> <ul class="nav-list"><li class="nav-list-item"><a href="/2024/" class="nav-list-link">Home</a></li><li class="nav-list-item"><a href="/2024/pages/about/" class="nav-list-link">About CMPUT 605</a></li><li class="nav-list-item"><a href="/2024/pages/about_cmput653/" class="nav-list-link">About CMPUT 653 (OLD)</a></li><li class="nav-list-item"><a href="/2024/pages/lectures/" class="nav-list-link">Lectures</a></li><li class="nav-list-item"><a href="/2024/pages/assignments/" class="nav-list-link">The work you do</a></li></ul> <div class="nav-category">Lecture Notes</div> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Planning in MDPs category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/lecture-notes/planning-in-mdps" class="nav-list-link">Planning in MDPs</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec1/" class="nav-list-link">1. Introductions</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec2/" class="nav-list-link">2. The Fundamental Theorem</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec3/" class="nav-list-link">3. Value Iteration and Our First Lower Bound</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec4/" class="nav-list-link">4. Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec5/" class="nav-list-link">5. Online Planning - Part I.</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec6/" class="nav-list-link">6. online planning - Part II.</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec7/" class="nav-list-link">7. Function Approximation</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec8/" class="nav-list-link">8. Approximate Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec9/" class="nav-list-link">9. Limits of query-efficient planning</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec10/" class="nav-list-link">10. Planning under $q^*$ realizability</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec11/" class="nav-list-link">11. Planning under $v^*$ realizability (TensorPlan I.)</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec12/" class="nav-list-link">12. TensorPlan and eluder sequences</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec13/" class="nav-list-link">13. From API to Politex</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec14/" class="nav-list-link">14. Politex</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec15/" class="nav-list-link">15. From policy search to policy gradients</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/planning-in-mdps/lec16/" class="nav-list-link">16. Policy gradients</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Online RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/lecture-notes/online-rl" class="nav-list-link">Online RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/lecture-notes/online-rl/lec22/" class="nav-list-link">22. Introduction</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/online-rl/lec23/" class="nav-list-link">23. Tabular MDPs</a></li><li class="nav-list-item "><a href="/2024/lecture-notes/online-rl/lec24/" class="nav-list-link">24. Featurized MDPs</a></li></ul></li></ul> <div class="nav-category">Winter 2022 Lecture Notes</div> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Planning in MDPs category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2022-lecture-notes/planning-in-mdps" class="nav-list-link">Planning in MDPs</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec1/" class="nav-list-link">1. Introductions</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec2/" class="nav-list-link">2. The Fundamental Theorem</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec3/" class="nav-list-link">3. Value Iteration and Our First Lower Bound</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec4/" class="nav-list-link">4. Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec5/" class="nav-list-link">5. Online Planning - Part I.</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec6/" class="nav-list-link">6. online planning - Part II.</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec7/" class="nav-list-link">7. Function Approximation</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec8/" class="nav-list-link">8. Approximate Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec9/" class="nav-list-link">9. Limits of query-efficient planning</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec10/" class="nav-list-link">10. Planning under $q^*$ realizability</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec11/" class="nav-list-link">11. Planning under $v^*$ realizability (TensorPlan I.)</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec12/" class="nav-list-link">12. TensorPlan and eluder sequences</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec13/" class="nav-list-link">13. From API to Politex</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec14/" class="nav-list-link">14. Politex</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec15/" class="nav-list-link">15. From policy search to policy gradients</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/planning-in-mdps/lec16/" class="nav-list-link">16. Policy gradients</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Batch RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2022-lecture-notes/batch-rl" class="nav-list-link">Batch RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/batch-rl/lec17/" class="nav-list-link">17. Introduction</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/batch-rl/lec18/" class="nav-list-link">18. Sample complexity in finite MDPs</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/batch-rl/lec19/" class="nav-list-link">19. Scaling with value function approximation</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Online RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2022-lecture-notes/online-rl" class="nav-list-link">Online RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/online-rl/lec22/" class="nav-list-link">22. Introduction</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/online-rl/lec23/" class="nav-list-link">23. Tabular MDPs</a></li><li class="nav-list-item "><a href="/2024/w2022-lecture-notes/online-rl/lec24/" class="nav-list-link">24. Featurized MDPs</a></li></ul></li></ul> <div class="nav-category">Winter 2021 Lecture Notes</div> <ul class="nav-list"><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Planning in MDPs category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2021-lecture-notes/planning-in-mdps" class="nav-list-link">Planning in MDPs</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec1/" class="nav-list-link">1. Introductions</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec2/" class="nav-list-link">2. The Fundamental Theorem</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec3/" class="nav-list-link">3. Value Iteration and Our First Lower Bound</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec4/" class="nav-list-link">4. Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec5/" class="nav-list-link">5. Local Planning - Part I.</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec6/" class="nav-list-link">6. Local Planning - Part II.</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec7/" class="nav-list-link">7. Function Approximation</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec8/" class="nav-list-link">8. Approximate Policy Iteration</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec9/" class="nav-list-link">9. Limits of query-efficient planning</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec10/" class="nav-list-link">10. Planning under $q^*$ realizability</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec11/" class="nav-list-link">11. Planning under $v^*$ realizability (TensorPlan I.)</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec12/" class="nav-list-link">12. TensorPlan and eluder sequences</a></li><li class="nav-list-item active"><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec13/" class="nav-list-link active">13. From API to Politex</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec14/" class="nav-list-link">14. Politex</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec15/" class="nav-list-link">15. From policy search to policy gradients</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/planning-in-mdps/lec16/" class="nav-list-link">16. Policy gradients</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Batch RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2021-lecture-notes/batch-rl" class="nav-list-link">Batch RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/batch-rl/lec17/" class="nav-list-link">17. Introduction</a></li><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/batch-rl/lec18/" class="nav-list-link">18. Sample complexity in finite MDPs</a></li></ul></li><li class="nav-list-item"><button class="nav-list-expander btn-reset" aria-label="toggle items in Online RL category" aria-pressed="false"> <svg viewBox="0 0 24 24" aria-hidden="true"><use xlink:href="#svg-arrow-right"></use></svg> </button><a href="/2024/w2021-lecture-notes/online-rl" class="nav-list-link">Online RL</a><ul class="nav-list"><li class="nav-list-item "><a href="/2024/w2021-lecture-notes/online-rl/blank/" class="nav-list-link">Blank</a></li></ul></li></ul> </nav> <footer class="site-footer"> Website of the course CMPUT 653: Theoretical Foundations of Reinforcement Learning. </footer> </div> <div class="main" id="top"> <div id="main-header" class="main-header"> <div class="search"> <div class="search-input-wrap"> <input type="text" id="search-input" class="search-input" tabindex="0" placeholder="Search RL Theory" aria-label="Search RL Theory" autocomplete="off"> <label for="search-input" class="search-label"><svg viewBox="0 0 24 24" class="search-icon"><use xlink:href="#svg-search"></use></svg></label> </div> <div id="search-results" class="search-results"></div> </div> </div> <div id="main-content-wrap" class="main-content-wrap"> <nav aria-label="Breadcrumb" class="breadcrumb-nav"> <ol class="breadcrumb-nav-list"> <li class="breadcrumb-nav-list-item"><a href="">Planning in MDPs</a></li> <li class="breadcrumb-nav-list-item"><span>13. From API to Politex</span></li> </ol> </nav> <div id="main-content" class="main-content" role="main"> <!-- Taken from https://github.com/jekyll/minima/blob/master/_layouts/post.html --> <header class="post-header"> <h1 class="post-title p-name" itemprop="name headline">13. From API to Politex</h1> <p class="text-small text-grey-dk-000 mb-0 mr-2"><time class="dt-published" datetime="2024-09-21T14:43:24-06:00" itemprop="datePublished"> Sep 21, 2024 </time></p> </header><p>In the <a href="/lecture-notes/planning-in-mdps/lec8/">lecture on approximate policy iteration</a>, we proved that for any MDP feature-map pair $(M,\phi)$ and any $\varepsilon’&gt;0$ excess suboptimality target, with a total runtime of</p> \[\text{poly}\left( d, \frac{1}{1-\gamma}, A, \frac{1}{\varepsilon'} \right)\,,\] <p>least-squares policy iteration with $G$-optimal design (LSPI-G) can produce a policy $\pi$ such that the suboptimality gap $\delta$ of $\pi$ satisfies</p> \[\begin{align} \delta \le \frac{2(1+\sqrt{d})}{(1-\gamma)^{\color{red} 2}} \varepsilon + \varepsilon'\,, \label{eq:lspiup} \end{align}\] <p>where \(\varepsilon\) is the worst-case error with which the $d$-dimensional features can approximate the action-value functions of memoryless policies of the MDP $M$. In fact, the result continues to hold if we restrict the memoryless policies to those that are <strong>$\phi$-measurable</strong> in the sense that the probability assigned by such a policy to taking some action $a$ in some state $s$ depends only on \(\phi(s,\cdot)\). Denote the set of such policies by \(\Pi_\phi\). Then, for an MDP $M$ and associated feature-map $\phi$, let</p> \[\tilde\varepsilon(M,\phi) = \sup_{\pi \in \Pi_\phi}\inf_{\theta} \|\Phi \theta - q^\pi\|_\infty\,.\] <p>Checking the proof, noticing that LSPI produces \(\phi\)-measurable policies only, it follows that provided the first policy it uses is also \(\phi\)-measurable, $\varepsilon$ in \eqref{eq:lspiup} can be replaced by \(\tilde \varepsilon(M,\phi)\).</p> <p><a href="/lecture-notes/planning-in-mdps/lec9/">Earlier</a>, we also proved that the amplification of $\varepsilon$ by the $\sqrt{d}$-factor is unavoidable by <strong>any</strong> efficient planner. However, this leaves open the question of whether the amplification by a polynomial power of $1/(1-\gamma)$ is necessary, and whether in particular, the quadratic dependence is necessary? Our first result, which is given without proof, shows that in the case of LSPI this amplification is real and the quadratic dependence cannot be improved.</p> <hr /> <p><strong>Theorem (LSPI error amplification lower bound):</strong> The quadratic dependence in \eqref{eq:lspiup} is tight: There exists a constant $c&gt;0$ such that for every $0\le \gamma&lt;1$ and every \(\varepsilon&gt;0\) there exists a featurized MDP \((M,\phi)\), a policy \(\pi\) of the MDP, a distribution \(\mu\) over the states such that LSPI when it is allowed infinitely many rollouts of infinite length produces a sequence of policies \(\pi_0=\pi,\pi_1,\dots\) such that</p> \[\inf_{k\ge 1} \mu (v^*-v^{\pi_k}) \ge \frac{c\tilde\varepsilon(M,\phi)}{(1-\gamma)^2}\,.\] <hr /> <!-- TODO: There is a gap here; Russo only proves the result for a the uniform distribution over the states. Need to be checked for G-optimal design --> <p>The result of the theorem holds even when LSPI is used with <strong>state-aggregation</strong>. Intuitively, state-aggregation means that states are groups into a number of groups and states belonging to the same group are treated identically when it comes to representing value functions. This, value-functions based on state-aggregation are constant over any group. When we are concerned with state-value functions, aggregating the states based on a partitioning of the states \(\mathcal{S}\) into the groups \(\{\mathcal{S}_i\}_{1\le i \le d}\) (i.e., \(\mathcal{S}_i\subset \mathcal{S}\) and all the subsets are disjoint from each other), a feature-map that allows to represent these piecewise constant functions is</p> \[\phi_i(s) = \mathbb{I}(s\in \mathcal{S}_i)\,, \qquad i\in [d]\,,\] <p>where $\mathbb{I}$ is the indicator function that takes the value of one when its argument (a logical expression) is true, and is zero otherwise. In other words, \(\phi: \mathcal{S} \to \{ e_1,\dots,e_d\}\). Any feature map of this form defines a partitioning of the state-space and thus corresponds to the state-aggregation. Note that the piecewise constant functions can also be represented if we rotate all the features by the same rotation. The only important aspect here is that the features of different states are either identical, or orthogonal to each other, making the rows of the feature matrix an <strong>orthonormal</strong> system.</p> <p>For approximating action-value functions, state-aggregation uses the same partitioning of states regardless of the identity of the actions: In effect, for each action, one uses the feature map from above, but with a private parameter vector. This effectively amounts to stacking $\phi(s)$ \(\mathrm{A}\)-times, to get one copy of it for each action $a\in \mathcal{A}$. Note that for state-aggregation, there is no $\sqrt{d}$ amplification of the approximation errors: State-aggregation is extrapolation friendly, as will be explained at the end of the lecture. <!-- Open: have both \sqrt{d} and the quadratic horizon dependence in the lower bound.--></p> <p>Returning to the result, an inspection of the actual proof reveals that in this case LSPI leads to a sequence of policies that alternate between the initial policy and $\pi_1$. “Convergence” is fast, yet, the guarantee is far from satisfactory. In particular, in the same example, an alternate algorithm, which we will cover next can <strong>reduce the quadratic dependence on the horizon to a linear dependence</strong>.</p> <h2 id="politex">Politex</h2> <p>Politex comes from <strong>Po</strong>licy <strong>It</strong>eration with <strong>Ex</strong>pert Advice. Assume that one is given a featurized MDP \((M,\phi)\) with state-action feature-map \(\phi\) and access to a simulator, and a $G$-optimal design \(\mathcal{C}\subset \mathcal{S}\times\mathcal{A}\) for \(\phi\).</p> <p>Politex generates a sequence of policies \(\pi_0,\pi_1,\dots\) such that for \(k\ge 1\),</p> \[\pi_k(a|s) \propto \exp\left( \eta \bar q_{k-1}(s,a)\right)\,,\] <p>where</p> \[\bar q_{k} = \hat q_0 + \dots + \hat q_j,\] <p>with</p> \[\hat q_j = \Pi \Phi \hat \theta_j,\] <p>where for \(j\ge 0\), \(\hat\theta_j\) is the parameter vector obtained by running the least-squares policy evaluation algorithm based on G-optimal design (LSPE-G) to evaluate policy \(\pi_j\) (see <a href="/lecture-notes/planning-in-mdps/lec8/">this</a> lecture). In particular, recall that this algorithm rolls out policy \(\pi_j\) from the points of a G-optimal design to produce \(m\) independent trajectories of length \(H\) each, calculates the average return for each of these design points and then solves the (weighted) least-squares regression problem where the features are used to regress on the obtained values.</p> <p>Above, \(\Pi : \mathbb{R}^{\mathcal{S}\times\mathcal{S}} \to \mathbb{R}^{\mathcal{S}\times\mathcal{S}}\) truncates its argument to the \([0,1/(1-\gamma)]\) interval:</p> \[(\Pi q)(s,a) = \max(\min( q(s,a), 1/(1-\gamma)), 0), \qquad (s,a) \in \mathcal{S}\times \mathcal{A}\,.\] <p>Note that to calculate \(\pi_k(a\vert s)\), one does needs to calculate \(E_k(s,a)=\exp\left( \eta \phi(s,a)^\top \bar \theta_{k-1}\right)\) and then compute \(\pi_k(a\vert s) = E_k(s,a)/\sum_{a'} E_k(s,a')\).</p> <p>Unlike in policy iteration, the policy returned by Politex after $k$ iterations is either the “mixture policy”</p> \[\bar \pi_k = \frac{1}{k} (\pi_0+\dots+\pi_{k-1})\,,\] <p>or the policy which gives the best value with respect to the start state, or start distribution. For simplicity, let us just consider the case when $\bar \pi_k$ is used as the output. <!-- homework --> The meaning of a mixture policy is simply that one of the $k$ policies is selected uniformly at random and then the selected policy is followed for the rest of time. <a href="/documents/assignments/assignment3.pdf">Homework 3</a> gives precise definitions and asks you to prove that the value function of $\bar \pi_k$ is just the mean of the value functions of the constituent policies:</p> \[\begin{align} v^{\bar \pi_k} = \frac1n \left(v^{\pi_0}+\dots+v^{\pi_{k-1}}\right)\,. \label{eq:avgpol} \end{align}\] <p>We now argue that the dependence on the approximation error of the suboptimality gap of $\bar \pi_k$ only scales with $1/(1-\gamma)$, unlike the case of approximate policy iteration.</p> <p>For this, recall that by the value difference identity</p> \[v^{\pi^*} - v^{\pi_j} = (I-\gamma P_{\pi^*})^{-1} \left[T_{\pi^*} v^{\pi_j} - v^{\pi_j} \right]\,.\] <p>Summing up, dividing by $k$, and using \eqref{eq:avgpol} gives</p> \[v^{\pi^*} - v^{\bar \pi_k} = \frac1k (I-\gamma P_{\pi^*})^{-1} \sum_{j=0}^{k-1} T_{\pi^*} v^{\pi_j} - v^{\pi_j}\,.\] <p>Now, \(T_{\pi^*} v^{\pi_j} = M_{\pi^*} (r+\gamma P v^{\pi_j}) = M_{\pi^*} q^{\pi_j}\). Also, \(v^{\pi_j} = M_{\pi_j} q^{\pi_j}\). Let \(\hat q_j = \Pi \Phi \hat \theta_j\). Elementary algebra then gives</p> \[\begin{align*} v^{\pi^*} - v^{\bar \pi_k} &amp; = \frac1k (I-\gamma P_{\pi^*})^{-1} \sum_{j=0}^{k-1} M_{\pi^*} q^{\pi_j} - M_{\pi_j} q^{\pi_j}\\ &amp; = \frac1k(I-\gamma P_{\pi^*})^{-1} \underbrace{ \sum_{j=0}^{k-1} M_{\pi^*} \hat q_j - M_{\pi_j} \hat q_j}_{T_1} + \underbrace{\frac1k (I-\gamma P_{\pi^*})^{-1} \sum_{j=0}^{k-1} ( M_{\pi^*} - M_{\pi_j} )( q^{\pi_j}-\hat q_j)}_{T_2} \,. \end{align*}\] <p>We see that the approximation errors $\varepsilon_j = q^{\pi_j}-\hat q_j$ appear only in term $T_2$. In particular, taking pointwise absolute values, using the triangle inequality, we get that</p> \[\|T_2\|_\infty \le \frac{2}{1-\gamma} \max_{0\le j \le k-1}\| \varepsilon_j\|_\infty\,,\] <p>which shows the promised dependence. It remains to show that \(\|T_1\|_\infty\) above is also under control. However, this is left to the next lecture.</p> <h2 id="notes">Notes</h2> <h3 id="state-aggregation-and-extrapolation-friendliness">State aggregation and extrapolation friendliness</h3> <p>The $\sqrt{d}$ in our results comes from controlling the extrapolation errors of linear prediction. In the case of state-aggregretion, however, this extra \(\sqrt{d}\) error amplification is completely avoided: Clearly, if we measure a function with a precision \(\varepsilon\) and there is at least one measurement per part, then by using the value measured at each part (at an arbitrary state there) over the whole part, the worst-case error is bounded by \(\varepsilon\). Weighted least-squares in this context just takes the weighted average of the responses over each part and uses this as the prediction, so it also avoids amplifying approximation errors. <!-- homework--></p> <p>In this case, our analysis of extrapolation errors is clearly conservative. The extrapolation error was controlled in two steps: In our first <a href="/lecture-notes/planning-in-mdps/lec8/#lem:lsee">lemma</a>, for \(\rho\) weighted least-squares we reduced this problem to that of controlling \(g(\rho)=\max_{z\in \mathcal{Z}} \| \phi(z) \|_{G_{\rho}^{-1}}\) where \(G_{\rho}\) is the moment matrix for \(\rho\). In fact, the proof of this lemma is the culprit: By carefully inspecting the proof, we can see that the application of Jensen’s inequality introduces an unnecessary term: For the case of state aggregation (orthonormed feature matrix),</p> \[\sum_{z' \in C} \varrho(z') \varepsilon(z') \varphi(z') = 1\,\] <p>as long as the design \(\rho\) is such that it chooses any group exactly once. Thus, the case of state-aggregation shows that some feature-maps are more <strong>extrapolation friendly</strong> than others. Also, note that the Kiefer-Wolfowitz theorem, of course, still gives that \(\sqrt{d}\) is the smallest value that we can get for \(g\) when optimizing for \(\rho\).</p> <p>It is a fascinating question of how extrapolation errors behave for various feature-maps. <!-- vague open question--></p> <h3 id="least-squares-value-iteration-lsvi">Least-squares value iteration (LSVI)</h3> <p>In <a href="/documents/assignments/assignment2.pdf">homework 2</a>, Question 3 was concerned with least-squares value iteration. The algorithm concerned (call it LSVI-G) uses a random approximation of the Bellman operator, based on a G-optimal design (and action-value functions). The problem was to show a result similar to what holds for LSPI-G holds for LSVI-G, as well. That is, for any MDP feature-map pair $(M,\phi)$ and any $\varepsilon’&gt;0$ excess suboptimality target, with a total runtime of</p> \[\text{poly}\left( d, \frac{1}{1-\gamma}, A, \frac{1}{\varepsilon'} \right)\,,\] <p>least-squares policy iteration with $G$-optimal design (LSPI-G) can produce a policy $\pi$ such that the suboptimality gap $\delta$ of $\pi$ satisfies</p> \[\begin{align} \delta \le \frac{4(1+\sqrt{d})}{(1-\gamma)^{\color{red} 2}} \varepsilon_\text{BOO} + \varepsilon'\,. \label{eq:lsviup} \end{align}\] <p>Thus, the dependence on the horizon of the approximation error is similar to the one that was obtained for LSPI. Note that the definition of \(\varepsilon_\text{BOO}\) is different from what we have used in analyzing LSPI:</p> \[\varepsilon_{\text{BOO}} := \sup_{\theta}\inf_{\theta'} \| \Phi \theta' - T \Pi \Phi \theta \|_\infty\,.\] <p>Above, \(T\) is the Bellman optimality oerator for action-value functions and $\Pi$ is defined so that for \(f:\mathcal{S}\times \mathcal{A}\to \mathbb{R}\), \(\Pi f\) is also a $\mathcal{S}\times \mathcal{A}\to \mathbb{R}$ function which is obtained from $f$ by truncating for each input $(s,a)$ the value $f(s,a)$ to $[0,1/(1-\gamma)]$: <!-- do we need truncation in LSPI!?--> $(\Pi(f))(s,a) = \max(\min( f(s,a), 1/(1-\gamma) ), 0)$. In $\varepsilon_{\text{BOO}}$, “BOO” stands for “Bellman-optimality operator” in reference to the appearance of $T$ in the definition.</p> <p>In general, the error measures \(\varepsilon\) used in LSPI and \(\varepsilon_{\text{BOO}}\) are incomparable. <!-- TODO: what else can be said!? --> The latter quantity measures a “one-step error”, while \(\varepsilon\) is concerned with approximating functions defined over an infinite-horizon. <!-- homework: this dependence is also tight?--></p> <h3 id="linear-mdps">Linear MDPs</h3> <p>Call an <strong>MDP linear</strong> if both the reward function and the next state distributions for each state lie in the span of the features: \(r = \Phi \theta_r\) with some $\theta_r\in \mathbb{R}^d$ and $P$, as an $\mathrm{S}\mathrm{A}\times \mathrm{S}$ matrix takes the form \(P = \Phi W\) with some \(W\in \mathbb{R}^{d\times \mathrm{S}}\). Clearly, this is a notion that captures how well the “dynamics” (including the reward) of the MDP can be “compressed”.</p> <p>When an MDP is linear, \(\varepsilon_{\text{BOO}}=0\). We also have in this case that $\varepsilon=0$. More generally, defining \(\zeta_r = \inf_{\theta}\| \Phi \theta_r - r \|_\infty\) and \(\zeta_P=\inf_W \|\Phi W - P \|_\infty\), it is not hard to see that \(\varepsilon_{\text{BOO}}\le \zeta_r + \zeta_P/(1-\gamma)\) and \(\varepsilon\le \frac{1}{1-\gamma} (\zeta_r + \zeta_P/(1-\gamma))\), which shows that both policy iteration (and its soft versions) and value iteration are “valid” approaches, though, by ignoring the fact that we are comparing upper bounds, this also shows that value iteration may have an edge over policy iteration when the MDP itself is compressible. This should not be too surprising given that value-iteration is “more direct” in aiming to calculate \(q^*\). Yet, they may exist cases when the action-value functions are compressible, while the dynamics is not. <!--- loads of speculation --></p> <h3 id="stationary-points-of-a-policy-search-objective">Stationary points of a policy search objective</h3> <p>Let \(J(\pi) = \mu v^\pi\). A stationary point of \(J\) with respect to some set of memoryless policies \(\Pi\) is any \(\pi\in \Pi\) such that</p> \[\langle \nabla J(\pi), \pi'- \pi \rangle \le 0\,.\] <p>It is known that if $\phi$ are state-aggregation features then any stationary point \(\pi\) of \(J\) satisfies</p> \[\nu v^\pi \ge \nu v^* - \frac{4\varepsilon_{\text{apx}}}{1-\gamma}\,,\] <p>where $\varepsilon_{\text{apx}}$ is defines as the worst-case error of approximation action-value functions of $\phi$-measurable policies with the features (the same constant as used in the analysis of approximate policy iteration).</p> <h3 id="soft-policy-iteration">Soft-policy iteration</h3> <p>Politex can be seen as a “soft” version of policy iteration. The softness is controlled by $\eta$: When $\eta\to \infty$, Politex reduces to LSPI-G. <!-- homework? --> As we have seen, in this case the approximation error can get quadratically amplified with the horizon $1/(1-\gamma)$. Thus, it is important to stay soft. As we shall see in the next lecture, the price of this a relatively slower convergence to a target suboptimality excess value. Nevertheless, the promise is that the algorithm will still stay polynomial in all the relevant quantities.</p> <h2 id="references">References</h2> <p>Politex was introduced in the paper</p> <ul> <li>POLITEX: Regret Bounds for Policy Iteration using Expert Prediction. Abbasi-Yadkori, Y.; Bartlett, P.; Bhatia, K.; Lazic, N.; Szepesvári, C.; and Weisz, G. In ICML, pages 3692–3702, May 2019. <a href="https://www.ualberta.ca/~szepesva/papers/ICML2019-Politex.pdf">pdf</a></li> </ul> <p>However, as this paper also notes, the basic idea goes back to the MDP-E algorithm by Even-Dar et al:</p> <ul> <li>Even-Dar, E., Kakade, S. M., and Mansour, Y. Online Markov decision processes. Mathematics of Operations Research, 34(3):726–736, 2009.</li> </ul> <p>This algorithm considered a tabular MDP with nonstationary rewards – a completely different setting. Nevertheless, this paper introduces the basic argument presented above. The Politex paper notices that the argument can be extended to the case of function approximation. In particular, it also notes the nature of the function approximator is irrelevant as long as the approximation and estimation errors can be tightly controlled.</p> <p>The Politex paper presented an analysis for online RL and average reward MDPs. Both add significant complications. The argument shown here is therefore a simpler version. Connecting Politex to LSPE-G in the discounted setting is trivial, but has not been presented before in the literature.</p> <p>The first paper to use the error decomposition shown here together with function approximation is</p> <ul> <li>Abbasi-Yadkori, Y., Lazic, N., and Szepesvári, C. Modelfree linear quadratic control via reduction to expert prediction. In AISTATS, 2019.</li> </ul> <hr> <footer> <p><a href="#top" id="back-to-top">Back to top</a></p> <p class="text-small text-grey-dk-100 mb-0">Copyright &copy; 2024 RL Theory.</p> <div class="d-flex mt-2"> </div> </footer> </div> </div> <div class="search-overlay"></div> </div> </body> </html>
